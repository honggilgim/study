# 자바에 대해서

자바에 대해서 공부하고, 정리해두는 파일입니다.

- HttpServletRequest : 컨트롤러로 들어온 정보를 모두 받아주는 역할을 합니다. Request 객체를 받아줍니다.
- Throwable : 예외처리를 할 수 있는 최상위 클래스입니다.


# 자바 기타 프로그램

JRebel : 소스의 변경사항을 자동으로 적용시켜 주어 서버 재시작이 필요 없도록 도와줍니다.

# super 

자식 클래스가 부모 클래스로부터 상속받은 멤버를 참조할 때 사용하는 참조 변수입니다.

# Super()

부모 클래스의 생성자를 호출하지만, 그냥 호출하는 것이 아닌 상속 관계에 따라 Object 클래스까지 올라갑니다. 자신의 클래스의 또다른 생성자 this 또는 부모 클래스의 생성자 super를 호출해야 모든 클래스가 동작합니다.

# 접근 제한자

하나의 객체가 다른 객체에 접근하려 할 때, 상속관계에서 상위 클래스가 하위 클래스에게 얼마나 많은 정보에 접근을 시켜야 할지 등등 접근 정도를 표시할 때 사용합니다.

-1. public : 공객합니다.

-2. private : 외부에서 접근을 금지합니다.

-3 protected : public과 private의 중간 예약어입니다. 구체적으로, 같은 패키지 안에서는 변수 공유가 되지만, 다른 패키지로 넘어가면 오류를 발생합니다.

# 메소드 오버로딩

한 클래스 내에서 매개변수의 타입, 순서, 갯수가 다르면 동일한 메소드명으로 얼마든지 선언이 가능한 속성입니다.

# 오버라이딩

클래스 상속과 밀접하게 연관되어 있습니다. 정의는, 메소드를 재정의하는 것인데 기존에 있던 메소드를 다시 정의하여 사용하는 것입니다.

# 자바 정적 필드, 정적 메소드

static : 정적 메소드를 표현하기 위한 예약어입니다.

필드 : 클래스 내부에서 사용되는 변수 혹은 객체입니다.

이 필드에 선언할 시, static 예약어를 붙여주면 정적 필드가 됩니다.

객체에 소속된 변수가 아닌, 클래스 자체에 소속된 변수가 됩니다. 클래스 변수이기에 heap 영역이 아닌 스택 영역에 할당되고, 그렇기에 프로그램 종료시까지 메모리에 남아 할당된 채로 존재합니다.

너무 남발하면 만들고자 하는 시스템에 악영향을 줍니다.

## 정적 메소드 정의하기

메소드에 static 예약어를 붙이면 됩니다.

주의사항으로, 정적 메소드에서는 정적 필드만을 취급할 수 있습니다. 저장되어 있는 메모리 영역이 다르기 때문에, static 메소드는 일반 메모리의 영역을 침범할 수 없습니다.

사용하고자 한다면, 클래스 명으로 정적 메소드를 사용해야 합니다. 객체 변수명은 사용할 수 없습니다.

## 정적 필드 초기화하기

정적 초기화 블록을 사용합니다.

static { ... } 으로 되어있는 형태이며, 위에서 아래로 순차적으로 실행됩니다.

# final

변수 : 값을 바꿀 수 없습니다. 그러나, 나머지는 일반 변수와 똑같습니다.

## final class

상속을 금지시킵니다. 상속을 방지하는 클래스입니다.

## final 메소드

오버라이딩을 금지시킵니다. 클래스 상속은 가능하지만, 몇 가지 메소드만 재정의하여 사용을 금지합니다. 실제 현업에서 자주 사용하지는 않지만, 여러 라이브러리의 정의에 사용되곤 합니다.

# 자바 클래스 생성자 new 예약어

생성자 모습 : 반드시 클래스명과 같아야 하고, 복귀 형태가 없어야 합니다.

디폴트 생성자 - public 클래스명 () {....}

우리가 생성자 정의를 해주지 않아도 기본으로 정의 된 생성자입니다.

new 예약어 - 객체를 생성할 때 사용합니다. 메모리에 해당 객체를 할당합니다.

생성자는 오버로딩이 가능합니다. 이것은 많이 사용됩니다.

# 자바 추상 클래스, 추상 메소드 (abstract)

클래스를 가지고 인스터스화 할 때, 우리는 추상 클래스를 통해 인스턴스화를 막을 수 있습니다.

추상 메소드 : abstract 메소드를 사용합니다. 메소드의 몸통부분을 생략시켜 상속받는 하위 클래스가 강제로 정의시키도록 합니다. 이클립스에서는 감지를 못해서, @override 어노테이션을 붙여야 합니다.
사용 이유는, 상위 클래스에서 가이드를 해주는 용도로 사용합니다. 이벤트 핸들러에서 주로 사용하는데, 스프링에서 Service에 interface용도로 정의해주는 것이 이것입니다.

# 인터페이스

자바에서는 다중 상속을 허용하지 않습니다. 그래서 중복 상속을 이용합니다. 하지만, 인터페이스는 여러 곳에서 상속이 가능하빈다. 그래서 필요가 있을 때 주로 사용합니다.

## 인터페이스의 모양(interface 예약어)

클래스에 넣을 때는 implement를 사용합니다. 인터페이스는 메소드의 모양만을 정의합니다. 그 이하 부분은, 클래스에서 재정의하여 사용합니다. implement + 인터페이스명을 사용하여 클래스 상속과 비슷한 개념을 사용합니다.

## 인터페이스 - 상속, 이벤트 핸들러

컴파일러는, 인터페이스의 메소드를 추상 메소드로 감지합니다. 즉, 재정의하여 사용해야 합니다. 인터페이스는 이벤트 핸들러로 주로 사용합니다. 이벤트 핸들러란, 특정 이벤트 발생 시, 이 이벤트의 결과나 상태를 처리할 수 있는 방법 및 수단입니다.

예시로, 스프링의 Service에 인터페이스를 정의해두고 사용하는 모습을 둘 수 있습니다. 이는, 해당 통신 패킷이 들어왔을 때 스레드에서 주기적인 이벤트가 발생할 때 사용합니다.

인터페이스는 객체를 선언할 수 없지만, 상수 필드는 선언이 가능합니다.

상수 필드에는 규칙이 들어가는데,

1. 생성과 동시에 초기화가 필수이며
2. 상수 필드의 기본 옵션은 public static입니다. 다만 이 문구는 붙이지 않아도 컴파일러가 알아서 붙입니다.
3. private, protected는 안됩니다. 100프로 오류납니다.

## 인터페이스의 상속

인터페이스들끼리도 상속이 가능합니다. 하지만 잘 사용하지는 않습니다. extends 예약어를 사용하며, 인터페이스들끼리는 다중 상속도 가능합니다.



# 입출력문

System 클래스에서 사용됩니다. java.lang 팩키지 안에 포함됩니다.

1. input, output 스트림

in, out 2개의 정적 객체가 존재합니다.
stream 은 데이터들이 일차원적 혹은 일렬로 흘러가는 형태입니다.

input, PrintStream 은, 입출력을 위한 스트림입니다.

input은 입력, PrintStream 은 출력으로 각각 in객체와 out 객체를 사용합니다.

## 출력함수

System.out.println을 사용합니다. 이것은 개행출력입니다. %d,변수명 의 형태를 사용하기도 하는데, 이는 c와 똑같습니다.

출력 변환문자열의 사용법
%10d : 버퍼의 크기를 10으로 잡고 우측 정렬
%10.3f : 버퍼의 크기를 10, 소수점을 3까지만 잡고 우측 정렬
% ,d : 숫자를 3자리씩 끊어서 보여줍니다.
% -10d : -가 붙으면, 좌측 정렬로 기준을 변경합니다.
% +d : 숫자의 부호를 출력합니다.
%010d : 버퍼의 남은 공간을 0으로 채워줍니다.
%(d : 음수를 괄호 안에 넣어줍니다.

# 자바 예외처리

try - catch 문을 이용합니다.

try 에서 예외를 감지하고, catch 에서 예외를 처리합니다. e변수가 예외를 넣어주는 변수입니다.

finally : 에러가 발생하거나 안하거나 반드시 실행해야 하는 부분입니다.

throws 예약어 : 예외를 던져줍니다.

- 예외 던지기 예시

IOEXCEPTION : input, output에 관한 예외를 던져줍니다. try-catch 구문으로 던진 에러를 처리해줘야 정상적으로 작동합니다.

- 인위적 예외 발생

프로그래머는, 예외를 인위적으로 발생시키는 일이 가능합니다. throw 구문을 사용하여 고의로 예외 발생이 가능합니다.

# 자바 데이터 타입

자바의 데이터 타입은, 프리미티브 타입과 레퍼런스 타입 2가지로 분류됩니다. 분류의 기준은, 메모리 참조 타입인가입니다.

프리미티브 타입은 메모리 공간에 직접 데이터를 넣습니다.
레퍼런스 타입은 다른곳을 참조하는 주소값을 담습니다.

- 프리미티브 타입
1. 정수 타입 : 숫자를 담는 타입입니다.
byte,short,int,long,char 등이 있고 크기의 차이가 존재합니다. char가 들어가는 이유는, 문자가 직접 입력되지 않고 문자를 대표하는 문자 코드값으로 입력되기 때문입니다. 그리고 c와 달리, 유니코드를 활용합니다.

2. 부동 소수점 타입 : 소수 점을 표현합니다. float, double 등이 있습니다.

3. 불리언 타입 : 참, 거짓의 데이터만 표현이 가능합니다. true, false 값을 가집니다.

- 레퍼런스 타입

클래스 타입, 인터페이스 타입, 배열 타입, 열거 타입이 존재합니다. c언어의 포인터와 같은 구조입니다. 객체를 선언하려 할당하면, 객체가 메모리 어딘가로 할당되고 실제 객체에는 메모리 참조값만을 받아오게 됩니다. 이것이 레퍼런스 타입의 기본 구조입니다.

null 값 : null 값을 넣어주는 이유는, 메모리 릴리즈 때문입니다. 가비지 컬렉터는 다 쓰고 난 후의 객체를 수집해서 해제합니다. 여기서 가비지는 참조가 다 끊어진 객체입니다. 재사용은 불가합니다.

레퍼런스 타입에는 수많은 세부내용이 존재합니다.

1. 상위 클래스 객체는 하위 클래스 객체와 호환됩니다.

상위 클래스 객체에 하위 클래스 객체를 담아 사용할 수 있습니다. 이렇게 사용할 경우, 상위 클래스의 기능밖에 사용하지 못합니다. 담긴것은 하위 클래스지만, 담는 그릇이 상위 클래스이기 때문입니다. 하위 클래스 기능을 사용하려면, 캐스트 연산자로 형변환을 수행하면 됩니다. 사용처는, 매개변수로 복잡한 자료형을 요구할 때, 그들의 공통 부모인 클래스를 매개 변수로 둘 경우 사용합니다.

2. 인터페이스 변수는 그 인터페이스로 구성된 클래스 객체에 대입할 수 있다.

대입받고 나면, Human 클래스에서 재정의된 추상 메서드를 그대로 사용할 수 있습니다.

## 형변환, instance of

형변환은, 상위 클래스 객체에 하위 클래스의 객체를 담아서 사용할 경우, 하위 클래스의 기능을 가지고 있음에도 불구하고 그릇이 상위 클래스이기 때문에 하위 클래스의 기능을 사용하지 못하는 경우에 대비하여 생겼습니다.

프리미티브 타입의 형 변환은,

```java
char a = 'c';
int b = (int)a;
```

와 같이 손쉽게 수행됩니다.

래퍼런스 타입의 형 변환은, 선언된 클래스 타입의 객체 주소만을 담는다는 보증 같은 것입니다.

instanceof : 형변환 하고자 하는 객체가 타겟 클래스 객체로 형변환이 가능한지 알아보는 연산자입니다. true-> 가능, false -> 불가능
