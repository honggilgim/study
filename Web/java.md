# 자바에 대해서

자바에 대해서 공부하고, 정리해두는 파일입니다.

- HttpServletRequest : 컨트롤러로 들어온 정보를 모두 받아주는 역할을 합니다. Request 객체를 받아줍니다.
- Throwable : 예외처리를 할 수 있는 최상위 클래스입니다.


# 자바 기타 프로그램

JRebel : 소스의 변경사항을 자동으로 적용시켜 주어 서버 재시작이 필요 없도록 도와줍니다.

# super 

자식 클래스가 부모 클래스로부터 상속받은 멤버를 참조할 때 사용하는 참조 변수입니다.

# Super()

부모 클래스의 생성자를 호출하지만, 그냥 호출하는 것이 아닌 상속 관계에 따라 Object 클래스까지 올라갑니다. 자신의 클래스의 또다른 생성자 this 또는 부모 클래스의 생성자 super를 호출해야 모든 클래스가 동작합니다.

# 접근 제한자

하나의 객체가 다른 객체에 접근하려 할 때, 상속관계에서 상위 클래스가 하위 클래스에게 얼마나 많은 정보에 접근을 시켜야 할지 등등 접근 정도를 표시할 때 사용합니다.

-1. public : 공객합니다.

-2. private : 외부에서 접근을 금지합니다.

-3 protected : public과 private의 중간 예약어입니다. 구체적으로, 같은 패키지 안에서는 변수 공유가 되지만, 다른 패키지로 넘어가면 오류를 발생합니다.

# 메소드 오버로딩

한 클래스 내에서 매개변수의 타입, 순서, 갯수가 다르면 동일한 메소드명으로 얼마든지 선언이 가능한 속성입니다.

# 오버라이딩

클래스 상속과 밀접하게 연관되어 있습니다. 정의는, 메소드를 재정의하는 것인데 기존에 있던 메소드를 다시 정의하여 사용하는 것입니다.

# 자바 정적 필드, 정적 메소드

static : 정적 메소드를 표현하기 위한 예약어입니다.

필드 : 클래스 내부에서 사용되는 변수 혹은 객체입니다.

이 필드에 선언할 시, static 예약어를 붙여주면 정적 필드가 됩니다.

객체에 소속된 변수가 아닌, 클래스 자체에 소속된 변수가 됩니다. 클래스 변수이기에 heap 영역이 아닌 스택 영역에 할당되고, 그렇기에 프로그램 종료시까지 메모리에 남아 할당된 채로 존재합니다.

너무 남발하면 만들고자 하는 시스템에 악영향을 줍니다.

## 정적 메소드 정의하기

메소드에 static 예약어를 붙이면 됩니다.

주의사항으로, 정적 메소드에서는 정적 필드만을 취급할 수 있습니다. 저장되어 있는 메모리 영역이 다르기 때문에, static 메소드는 일반 메모리의 영역을 침범할 수 없습니다.

사용하고자 한다면, 클래스 명으로 정적 메소드를 사용해야 합니다. 객체 변수명은 사용할 수 없습니다.

## 정적 필드 초기화하기

정적 초기화 블록을 사용합니다.

static { ... } 으로 되어있는 형태이며, 위에서 아래로 순차적으로 실행됩니다.

# final

변수 : 값을 바꿀 수 없습니다. 그러나, 나머지는 일반 변수와 똑같습니다.

## final class

상속을 금지시킵니다. 상속을 방지하는 클래스입니다.

## final 메소드

오버라이딩을 금지시킵니다. 클래스 상속은 가능하지만, 몇 가지 메소드만 재정의하여 사용을 금지합니다. 실제 현업에서 자주 사용하지는 않지만, 여러 라이브러리의 정의에 사용되곤 합니다.

# 자바 클래스 생성자 new 예약어

생성자 모습 : 반드시 클래스명과 같아야 하고, 복귀 형태가 없어야 합니다.

디폴트 생성자 - public 클래스명 () {....}

우리가 생성자 정의를 해주지 않아도 기본으로 정의 된 생성자입니다.

new 예약어 - 객체를 생성할 때 사용합니다. 메모리에 해당 객체를 할당합니다.

생성자는 오버로딩이 가능합니다. 이것은 많이 사용됩니다.

# 자바 추상 클래스, 추상 메소드 (abstract)

클래스를 가지고 인스터스화 할 때, 우리는 추상 클래스를 통해 인스턴스화를 막을 수 있습니다.

추상 메소드 : abstract 메소드를 사용합니다. 메소드의 몸통부분을 생략시켜 상속받는 하위 클래스가 강제로 정의시키도록 합니다. 이클립스에서는 감지를 못해서, @override 어노테이션을 붙여야 합니다.
사용 이유는, 상위 클래스에서 가이드를 해주는 용도로 사용합니다. 이벤트 핸들러에서 주로 사용하는데, 스프링에서 Service에 interface용도로 정의해주는 것이 이것입니다.

# 인터페이스

자바에서는 다중 상속을 허용하지 않습니다. 그래서 중복 상속을 이용합니다. 하지만, 인터페이스는 여러 곳에서 상속이 가능하빈다. 그래서 필요가 있을 때 주로 사용합니다.

## 인터페이스의 모양(interface 예약어)

클래스에 넣을 때는 implement를 사용합니다. 인터페이스는 메소드의 모양만을 정의합니다. 그 이하 부분은, 클래스에서 재정의하여 사용합니다. implement + 인터페이스명을 사용하여 클래스 상속과 비슷한 개념을 사용합니다.

## 인터페이스 - 상속, 이벤트 핸들러

컴파일러는, 인터페이스의 메소드를 추상 메소드로 감지합니다. 즉, 재정의하여 사용해야 합니다. 인터페이스는 이벤트 핸들러로 주로 사용합니다. 이벤트 핸들러란, 특정 이벤트 발생 시, 이 이벤트의 결과나 상태를 처리할 수 있는 방법 및 수단입니다.

예시로, 스프링의 Service에 인터페이스를 정의해두고 사용하는 모습을 둘 수 있습니다. 이는, 해당 통신 패킷이 들어왔을 때 스레드에서 주기적인 이벤트가 발생할 때 사용합니다.

인터페이스는 객체를 선언할 수 없지만, 상수 필드는 선언이 가능합니다.

상수 필드에는 규칙이 들어가는데,

1. 생성과 동시에 초기화가 필수이며
2. 상수 필드의 기본 옵션은 public static입니다. 다만 이 문구는 붙이지 않아도 컴파일러가 알아서 붙입니다.
3. private, protected는 안됩니다. 100프로 오류납니다.

## 인터페이스의 상속

인터페이스들끼리도 상속이 가능합니다. 하지만 잘 사용하지는 않습니다. extends 예약어를 사용하며, 인터페이스들끼리는 다중 상속도 가능합니다.


