# Mysql index

Mysql의 인덱스

SQL에서 인덱스는 테이블의 데이터에 대한 포인터를 말한다고 한다. 간단하게, 책의 목차와 같은 느낌이다.

인덱스가 적용된 데이터베이스는, select와 where의 속도를 높여준다. 하지만, insert와 update의 속도는 느려진다. 인덱스가 있고 없고에 따라 속도의 차이가 현저하기에, 필요하다면 꼭 생성하는 편이 좋다.

인덱스는 테이블 내에 데이터가 엄청나게 많을 경우 사용하는데 데이터가 얼마 없을 경우에는 오히려 느려진다는 점을 상기해야 한다.

프로젝트를 진행한다면, 학생 입장에서는 인덱스를 사용하지 않고 회사 입장에서는 사용하는 것이 좋아보인다.

RDBMS는, 데이터 영속화에 목적을 둔다. 이는, 어떤 애플리케이션에 필요한 데이터를 유지하고 저장하는 데 목적이 있다.

## 인덱스의 구조

대부분의 RDBMS는 기본적으로 b-tree(바이너리 트리)를 인덱스로 사용한다. 실질적으로 b-tree 인덱스를 쓴다느니, 조금씩 변형해서 쓰니니 하지만 인덱스의 추상적인 개념을 이해하기도 하고 다른 인덱스도 결국 베이스는 b-tree 인덱스이다.

인덱스 칼럼을 관리하기 위해서는 트리를 이용하는데, 최상위에는 루트 노드가 있고 가장 끝단에는 실제 레코드의 주소가 저장된 리프 노드가 있다.

이 둘 사이에는 브랜치 노드가 있다. 이 트리를 통해 타고 가면서 레코드를 찾는다.

실제 MySQL에서는, InnoDB 스토리지 엔진에서 기본으로 하는 인덱스는

![화면 캡처 2022-07-18 222510](https://user-images.githubusercontent.com/48556879/179521310-2e74da87-1aa0-4375-9de9-8173b587090b.jpg)

이렇게 생겼다고 한다. B-tree와의 차이는, 데이터 파일을 관리하는게 다르다고 한다. b-tree 인덱스에서는 데이터 파일이 순차적으로 있지 않고 여러 위치에 뒤죽박죽 순서로 저장되어 있어서 문제점이 있다.

이 문제는, 다른 페이지(위치)에 있다면 메모리로 읽어와야 할 페이지 수가 많아져서 I/O 효율이 떨어질 수 있다는 것이다.

이 문제점을 InnoDB의 인덱스는 데이터 파일에 저장 방식 자체를 프라이머리 키 인덱스로 정렬하여 관리하여 해결했다.

b-tree 인덱스의 마지막 노드에서는 프라이머리 키 값이 저장되어 있는데, 프라이머리 키 값으로 바로 해당 레코드를 찾을 수 있는 것이 아니라, 데이터 파일 저장 형식 자체가 인덱스이기에 인덱스를 한번 더 조회해야 실제 레코드에 접근이 가능하다.

## MySQL 인덱스 종류

프라이머리 키 인덱스 : 프라이머리 키를 기준으로 만들어지는 인덱스

세컨더리 키 인덱스 : 프라이머리 키를 제외한 모든 인덱스

가 있으며 프라이머리 키 인덱스는 반드시 존재한다. 왜냐하면 데이터 레코드 저장 자체를 프라이머리 키 인덱스로 하기 때문이다.


## 인덱스의 추가, 수정, 삭제방법

조회

show index from 테이블명;

인덱스 생성

create index 인덱스명 on 테이블명(컬럼명)
alter table 테이블명 add index 인덱스명(칼럼명)
둘 중 하나를 선택한다.

인덱스 삭제

alter table 테이블명 drop index 인덱스명;

인덱스 수정의 경우에는, 삭제한 후 다시 생성해주면 된다.

# RDB와 NoSQL의 차이

RDBMS는 정해진 스키마가 존재하고, NoSQL은 정해진 스키마가 없다는 것이 가장 큰 차이입니다. NoSQL은 정해진 스키마가 없을 때 데이터 구조 변화가 자유롭고 데이터 분산이 용이하지만, 데이터 중복이 발생하거나 데이터 변경 시에 연산이 오래 걸립니다.



